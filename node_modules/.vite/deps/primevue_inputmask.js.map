{
  "version": 3,
  "sources": ["../../src/inputmask/style/InputMaskStyle.js", "../../src/inputmask/BaseInputMask.vue", "../../src/inputmask/InputMask.vue", "../../src/inputmask/InputMask.vue?vue&type=template&id=1c680b6f&lang.js"],
  "sourcesContent": ["import BaseStyle from '@primevue/core/base/style';\n\nconst classes = {\n    root: 'p-inputmask'\n};\n\nexport default BaseStyle.extend({\n    name: 'inputmask',\n    classes\n});\n", "<script>\nimport BaseComponent from '@primevue/core/basecomponent';\nimport InputMaskStyle from 'primevue/inputmask/style';\n\nexport default {\n    name: 'BaseInputMask',\n    extends: BaseComponent,\n    props: {\n        modelValue: null,\n        slotChar: {\n            type: String,\n            default: '_'\n        },\n        mask: {\n            type: String,\n            default: null\n        },\n        placeholder: {\n            type: String,\n            default: null\n        },\n        autoClear: {\n            type: Boolean,\n            default: true\n        },\n        unmask: {\n            type: Boolean,\n            default: false\n        },\n        readonly: {\n            type: Boolean,\n            default: false\n        },\n        invalid: {\n            type: Boolean,\n            default: false\n        },\n        disabled: {\n            type: Boolean,\n            default: false\n        },\n        variant: {\n            type: String,\n            default: null\n        }\n    },\n    style: InputMaskStyle,\n    provide() {\n        return {\n            $pcInputMask: this,\n            $parentInstance: this\n        };\n    }\n};\n</script>\n", "<template>\n    <InputText\n        :value=\"modelValue\"\n        :class=\"cx('root')\"\n        :readonly=\"readonly\"\n        :disabled=\"disabled\"\n        :invalid=\"invalid\"\n        :variant=\"variant\"\n        :placeholder=\"placeholder\"\n        :unstyled=\"unstyled\"\n        @input=\"onInput\"\n        @focus=\"onFocus\"\n        @blur=\"onBlur\"\n        @keydown=\"onKeyDown\"\n        @keypress=\"onKeyPress\"\n        @paste=\"onPaste\"\n        :pt=\"ptmi('root', ptmParams)\"\n    />\n</template>\n\n<script>\nimport { DomHandler } from '@primevue/core/utils';\nimport InputText from 'primevue/inputtext';\nimport BaseInputMask from './BaseInputMask.vue';\n\nexport default {\n    name: 'InputMask',\n    extends: BaseInputMask,\n    inheritAttrs: false,\n    emits: ['update:modelValue', 'focus', 'blur', 'keydown', 'complete', 'keypress', 'paste'],\n    watch: {\n        mask(newMask, oldMask) {\n            if (oldMask !== newMask) {\n                this.initMask();\n            }\n        }\n    },\n    mounted() {\n        this.initMask();\n    },\n    updated() {\n        if (this.isValueUpdated()) {\n            this.updateValue();\n        }\n    },\n    methods: {\n        onInput(event) {\n            if (this.androidChrome) this.handleAndroidInput(event);\n            else this.handleInputChange(event);\n\n            this.$emit('update:modelValue', event.target.value);\n        },\n        onFocus(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            this.focus = true;\n\n            clearTimeout(this.caretTimeoutId);\n            let pos;\n\n            this.focusText = this.$el.value;\n\n            pos = this.checkVal();\n\n            this.caretTimeoutId = setTimeout(() => {\n                if (this.$el !== document.activeElement) {\n                    return;\n                }\n\n                this.writeBuffer();\n\n                if (pos === this.mask.replace('?', '').length) {\n                    this.caret(0, pos);\n                } else {\n                    this.caret(pos);\n                }\n            }, 10);\n\n            this.$emit('focus', event);\n        },\n        onBlur(event) {\n            this.focus = false;\n            this.checkVal();\n            this.updateModel(event);\n\n            if (this.$el.value !== this.focusText) {\n                let e = document.createEvent('HTMLEvents');\n\n                e.initEvent('change', true, false);\n                this.$el.dispatchEvent(e);\n            }\n\n            this.$emit('blur', event);\n        },\n        onKeyDown(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            let k = event.code,\n                pos,\n                begin,\n                end;\n            let iPhone = /iphone/i.test(DomHandler.getUserAgent());\n\n            this.oldVal = this.$el.value;\n\n            //backspace, delete, and escape get special treatment\n            if (k === 'Backspace' || k === 'Delete' || (iPhone && k === 'Escape')) {\n                pos = this.caret();\n                begin = pos.begin;\n                end = pos.end;\n\n                if (end - begin === 0) {\n                    begin = k !== 'Delete' ? this.seekPrev(begin) : (end = this.seekNext(begin - 1));\n                    end = k === 'Delete' ? this.seekNext(end) : end;\n                }\n\n                this.clearBuffer(begin, end);\n                this.shiftL(begin, end - 1);\n                this.updateModel(event);\n\n                event.preventDefault();\n            } else if (k === 'Enter') {\n                // enter\n                this.$el.blur();\n                this.updateModel(event);\n            } else if (k === 'Escape') {\n                // escape\n                this.$el.value = this.focusText;\n                this.caret(0, this.checkVal());\n                this.updateModel(event);\n                event.preventDefault();\n            }\n\n            this.$emit('keydown', event);\n        },\n        onKeyPress(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            var k = event.code,\n                pos = this.caret(),\n                p,\n                c,\n                next,\n                completed;\n\n            if (event.ctrlKey || event.altKey || event.metaKey || event.shiftKey || event.key === 'CapsLock' || event.key === 'Escape' || event.key === 'Tab') {\n                //Ignore\n                return;\n            } else if (k && k !== 'Enter') {\n                if (pos.end - pos.begin !== 0) {\n                    this.clearBuffer(pos.begin, pos.end);\n                    this.shiftL(pos.begin, pos.end - 1);\n                }\n\n                p = this.seekNext(pos.begin - 1);\n\n                if (p < this.len) {\n                    c = event.key;\n\n                    if (this.tests[p].test(c)) {\n                        this.shiftR(p);\n\n                        this.buffer[p] = c;\n                        this.writeBuffer();\n                        next = this.seekNext(p);\n\n                        if (/android/i.test(DomHandler.getUserAgent())) {\n                            //Path for CSP Violation on FireFox OS 1.1\n                            let proxy = () => {\n                                this.caret(next);\n                            };\n\n                            setTimeout(proxy, 0);\n                        } else {\n                            this.caret(next);\n                        }\n\n                        if (pos.begin <= this.lastRequiredNonMaskPos) {\n                            completed = this.isCompleted();\n                        }\n                    }\n                }\n\n                event.preventDefault();\n            }\n\n            this.updateModel(event);\n\n            if (completed) {\n                this.$emit('complete', event);\n            }\n\n            this.$emit('keypress', event);\n        },\n        onPaste(event) {\n            this.handleInputChange(event);\n\n            this.$emit('paste', event);\n        },\n        caret(first, last) {\n            let range, begin, end;\n\n            if (!this.$el.offsetParent || this.$el !== document.activeElement) {\n                return;\n            }\n\n            if (typeof first === 'number') {\n                begin = first;\n                end = typeof last === 'number' ? last : begin;\n\n                if (this.$el.setSelectionRange) {\n                    this.$el.setSelectionRange(begin, end);\n                } else if (this.$el['createTextRange']) {\n                    range = this.$el['createTextRange']();\n                    range.collapse(true);\n                    range.moveEnd('character', end);\n                    range.moveStart('character', begin);\n                    range.select();\n                }\n            } else {\n                if (this.$el.setSelectionRange) {\n                    begin = this.$el.selectionStart;\n                    end = this.$el.selectionEnd;\n                } else if (document['selection'] && document['selection'].createRange) {\n                    range = document['selection'].createRange();\n                    begin = 0 - range.duplicate().moveStart('character', -100000);\n                    end = begin + range.text.length;\n                }\n\n                return { begin: begin, end: end };\n            }\n        },\n        isCompleted() {\n            for (let i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {\n                if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n        getPlaceholder(i) {\n            if (i < this.slotChar.length) {\n                return this.slotChar.charAt(i);\n            }\n\n            return this.slotChar.charAt(0);\n        },\n        seekNext(pos) {\n            while (++pos < this.len && !this.tests[pos]);\n\n            return pos;\n        },\n        seekPrev(pos) {\n            while (--pos >= 0 && !this.tests[pos]);\n\n            return pos;\n        },\n        shiftL(begin, end) {\n            let i, j;\n\n            if (begin < 0) {\n                return;\n            }\n\n            for (i = begin, j = this.seekNext(end); i < this.len; i++) {\n                if (this.tests[i]) {\n                    if (j < this.len && this.tests[i].test(this.buffer[j])) {\n                        this.buffer[i] = this.buffer[j];\n                        this.buffer[j] = this.getPlaceholder(j);\n                    } else {\n                        break;\n                    }\n\n                    j = this.seekNext(j);\n                }\n            }\n\n            this.writeBuffer();\n            this.caret(Math.max(this.firstNonMaskPos, begin));\n        },\n        shiftR(pos) {\n            let i, c, j, t;\n\n            for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {\n                if (this.tests[i]) {\n                    j = this.seekNext(i);\n                    t = this.buffer[i];\n                    this.buffer[i] = c;\n\n                    if (j < this.len && this.tests[j].test(t)) {\n                        c = t;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        },\n        handleAndroidInput(event) {\n            var curVal = this.$el.value;\n            var pos = this.caret();\n\n            if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {\n                // a deletion or backspace happened\n                this.checkVal(true);\n                while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;\n\n                if (pos.begin === 0) {\n                    while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;\n                }\n\n                this.caret(pos.begin, pos.begin);\n            } else {\n                this.checkVal(true);\n                while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;\n\n                this.caret(pos.begin, pos.begin);\n            }\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        clearBuffer(start, end) {\n            let i;\n\n            for (i = start; i < end && i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n                }\n            }\n        },\n        writeBuffer() {\n            this.$el.value = this.buffer.join('');\n        },\n        checkVal(allow) {\n            this.isValueChecked = true;\n            //try to place characters where they belong\n            let test = this.$el.value,\n                lastMatch = -1,\n                i,\n                c,\n                pos;\n\n            for (i = 0, pos = 0; i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n\n                    while (pos++ < test.length) {\n                        c = test.charAt(pos - 1);\n\n                        if (this.tests[i].test(c)) {\n                            this.buffer[i] = c;\n                            lastMatch = i;\n                            break;\n                        }\n                    }\n\n                    if (pos > test.length) {\n                        this.clearBuffer(i + 1, this.len);\n                        break;\n                    }\n                } else {\n                    if (this.buffer[i] === test.charAt(pos)) {\n                        pos++;\n                    }\n\n                    if (i < this.partialPosition) {\n                        lastMatch = i;\n                    }\n                }\n            }\n\n            if (allow) {\n                this.writeBuffer();\n            } else if (lastMatch + 1 < this.partialPosition) {\n                if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {\n                    // Invalid value. Remove it and replace it with the\n                    // mask, which is the default behavior.\n                    if (this.$el.value) this.$el.value = '';\n                    this.clearBuffer(0, this.len);\n                } else {\n                    // Invalid value, but we opt to show the value to the\n                    // user and allow them to correct their mistake.\n                    this.writeBuffer();\n                }\n            } else {\n                this.writeBuffer();\n                this.$el.value = this.$el.value.substring(0, lastMatch + 1);\n            }\n\n            return this.partialPosition ? i : this.firstNonMaskPos;\n        },\n        handleInputChange(event) {\n            const isPasteEvent = event.type === 'paste';\n\n            if (this.readonly || isPasteEvent) {\n                return;\n            }\n\n            var pos = this.checkVal(true);\n\n            this.caret(pos);\n            this.updateModel(event);\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        getUnmaskedValue() {\n            let unmaskedBuffer = [];\n\n            for (let i = 0; i < this.buffer.length; i++) {\n                let c = this.buffer[i];\n\n                if (this.tests[i] && c !== this.getPlaceholder(i)) {\n                    unmaskedBuffer.push(c);\n                }\n            }\n\n            return unmaskedBuffer.join('');\n        },\n        updateModel(e) {\n            let val = this.unmask ? this.getUnmaskedValue() : e.target.value;\n\n            this.$emit('update:modelValue', this.defaultBuffer !== val ? val : '');\n        },\n        updateValue(updateModel = true) {\n            if (this.$el) {\n                if (this.modelValue == null) {\n                    this.$el.value = '';\n                    updateModel && this.$emit('update:modelValue', '');\n                } else {\n                    this.$el.value = this.modelValue;\n                    this.checkVal();\n\n                    setTimeout(() => {\n                        if (this.$el) {\n                            this.writeBuffer();\n                            this.checkVal();\n\n                            if (updateModel) {\n                                let val = this.unmask ? this.getUnmaskedValue() : this.$el.value;\n\n                                this.$emit('update:modelValue', this.defaultBuffer !== val ? val : '');\n                            }\n                        }\n                    }, 10);\n                }\n\n                this.focusText = this.$el.value;\n            }\n        },\n        initMask() {\n            this.tests = [];\n            this.partialPosition = this.mask.length;\n            this.len = this.mask.length;\n            this.firstNonMaskPos = null;\n            this.defs = {\n                9: '[0-9]',\n                a: '[A-Za-z]',\n                '*': '[A-Za-z0-9]'\n            };\n\n            let ua = DomHandler.getUserAgent();\n\n            this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);\n\n            let maskTokens = this.mask.split('');\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c === '?') {\n                    this.len--;\n                    this.partialPosition = i;\n                } else if (this.defs[c]) {\n                    this.tests.push(new RegExp(this.defs[c]));\n\n                    if (this.firstNonMaskPos === null) {\n                        this.firstNonMaskPos = this.tests.length - 1;\n                    }\n\n                    if (i < this.partialPosition) {\n                        this.lastRequiredNonMaskPos = this.tests.length - 1;\n                    }\n                } else {\n                    this.tests.push(null);\n                }\n            }\n\n            this.buffer = [];\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c !== '?') {\n                    if (this.defs[c]) this.buffer.push(this.getPlaceholder(i));\n                    else this.buffer.push(c);\n                }\n            }\n\n            this.defaultBuffer = this.buffer.join('');\n            this.updateValue(false);\n        },\n        isValueUpdated() {\n            return this.unmask ? this.modelValue != this.getUnmaskedValue() : this.defaultBuffer !== this.$el.value && this.$el.value !== this.modelValue;\n        }\n    },\n    computed: {\n        filled() {\n            return this.modelValue != null && this.modelValue.toString().length > 0;\n        },\n        ptmParams() {\n            return {\n                context: {\n                    filled: this.filled\n                }\n            };\n        }\n    },\n    components: {\n        InputText\n    }\n};\n</script>\n", "<template>\n    <InputText\n        :value=\"modelValue\"\n        :class=\"cx('root')\"\n        :readonly=\"readonly\"\n        :disabled=\"disabled\"\n        :invalid=\"invalid\"\n        :variant=\"variant\"\n        :placeholder=\"placeholder\"\n        :unstyled=\"unstyled\"\n        @input=\"onInput\"\n        @focus=\"onFocus\"\n        @blur=\"onBlur\"\n        @keydown=\"onKeyDown\"\n        @keypress=\"onKeyPress\"\n        @paste=\"onPaste\"\n        :pt=\"ptmi('root', ptmParams)\"\n    />\n</template>\n\n<script>\nimport { DomHandler } from '@primevue/core/utils';\nimport InputText from 'primevue/inputtext';\nimport BaseInputMask from './BaseInputMask.vue';\n\nexport default {\n    name: 'InputMask',\n    extends: BaseInputMask,\n    inheritAttrs: false,\n    emits: ['update:modelValue', 'focus', 'blur', 'keydown', 'complete', 'keypress', 'paste'],\n    watch: {\n        mask(newMask, oldMask) {\n            if (oldMask !== newMask) {\n                this.initMask();\n            }\n        }\n    },\n    mounted() {\n        this.initMask();\n    },\n    updated() {\n        if (this.isValueUpdated()) {\n            this.updateValue();\n        }\n    },\n    methods: {\n        onInput(event) {\n            if (this.androidChrome) this.handleAndroidInput(event);\n            else this.handleInputChange(event);\n\n            this.$emit('update:modelValue', event.target.value);\n        },\n        onFocus(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            this.focus = true;\n\n            clearTimeout(this.caretTimeoutId);\n            let pos;\n\n            this.focusText = this.$el.value;\n\n            pos = this.checkVal();\n\n            this.caretTimeoutId = setTimeout(() => {\n                if (this.$el !== document.activeElement) {\n                    return;\n                }\n\n                this.writeBuffer();\n\n                if (pos === this.mask.replace('?', '').length) {\n                    this.caret(0, pos);\n                } else {\n                    this.caret(pos);\n                }\n            }, 10);\n\n            this.$emit('focus', event);\n        },\n        onBlur(event) {\n            this.focus = false;\n            this.checkVal();\n            this.updateModel(event);\n\n            if (this.$el.value !== this.focusText) {\n                let e = document.createEvent('HTMLEvents');\n\n                e.initEvent('change', true, false);\n                this.$el.dispatchEvent(e);\n            }\n\n            this.$emit('blur', event);\n        },\n        onKeyDown(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            let k = event.code,\n                pos,\n                begin,\n                end;\n            let iPhone = /iphone/i.test(DomHandler.getUserAgent());\n\n            this.oldVal = this.$el.value;\n\n            //backspace, delete, and escape get special treatment\n            if (k === 'Backspace' || k === 'Delete' || (iPhone && k === 'Escape')) {\n                pos = this.caret();\n                begin = pos.begin;\n                end = pos.end;\n\n                if (end - begin === 0) {\n                    begin = k !== 'Delete' ? this.seekPrev(begin) : (end = this.seekNext(begin - 1));\n                    end = k === 'Delete' ? this.seekNext(end) : end;\n                }\n\n                this.clearBuffer(begin, end);\n                this.shiftL(begin, end - 1);\n                this.updateModel(event);\n\n                event.preventDefault();\n            } else if (k === 'Enter') {\n                // enter\n                this.$el.blur();\n                this.updateModel(event);\n            } else if (k === 'Escape') {\n                // escape\n                this.$el.value = this.focusText;\n                this.caret(0, this.checkVal());\n                this.updateModel(event);\n                event.preventDefault();\n            }\n\n            this.$emit('keydown', event);\n        },\n        onKeyPress(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            var k = event.code,\n                pos = this.caret(),\n                p,\n                c,\n                next,\n                completed;\n\n            if (event.ctrlKey || event.altKey || event.metaKey || event.shiftKey || event.key === 'CapsLock' || event.key === 'Escape' || event.key === 'Tab') {\n                //Ignore\n                return;\n            } else if (k && k !== 'Enter') {\n                if (pos.end - pos.begin !== 0) {\n                    this.clearBuffer(pos.begin, pos.end);\n                    this.shiftL(pos.begin, pos.end - 1);\n                }\n\n                p = this.seekNext(pos.begin - 1);\n\n                if (p < this.len) {\n                    c = event.key;\n\n                    if (this.tests[p].test(c)) {\n                        this.shiftR(p);\n\n                        this.buffer[p] = c;\n                        this.writeBuffer();\n                        next = this.seekNext(p);\n\n                        if (/android/i.test(DomHandler.getUserAgent())) {\n                            //Path for CSP Violation on FireFox OS 1.1\n                            let proxy = () => {\n                                this.caret(next);\n                            };\n\n                            setTimeout(proxy, 0);\n                        } else {\n                            this.caret(next);\n                        }\n\n                        if (pos.begin <= this.lastRequiredNonMaskPos) {\n                            completed = this.isCompleted();\n                        }\n                    }\n                }\n\n                event.preventDefault();\n            }\n\n            this.updateModel(event);\n\n            if (completed) {\n                this.$emit('complete', event);\n            }\n\n            this.$emit('keypress', event);\n        },\n        onPaste(event) {\n            this.handleInputChange(event);\n\n            this.$emit('paste', event);\n        },\n        caret(first, last) {\n            let range, begin, end;\n\n            if (!this.$el.offsetParent || this.$el !== document.activeElement) {\n                return;\n            }\n\n            if (typeof first === 'number') {\n                begin = first;\n                end = typeof last === 'number' ? last : begin;\n\n                if (this.$el.setSelectionRange) {\n                    this.$el.setSelectionRange(begin, end);\n                } else if (this.$el['createTextRange']) {\n                    range = this.$el['createTextRange']();\n                    range.collapse(true);\n                    range.moveEnd('character', end);\n                    range.moveStart('character', begin);\n                    range.select();\n                }\n            } else {\n                if (this.$el.setSelectionRange) {\n                    begin = this.$el.selectionStart;\n                    end = this.$el.selectionEnd;\n                } else if (document['selection'] && document['selection'].createRange) {\n                    range = document['selection'].createRange();\n                    begin = 0 - range.duplicate().moveStart('character', -100000);\n                    end = begin + range.text.length;\n                }\n\n                return { begin: begin, end: end };\n            }\n        },\n        isCompleted() {\n            for (let i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {\n                if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n        getPlaceholder(i) {\n            if (i < this.slotChar.length) {\n                return this.slotChar.charAt(i);\n            }\n\n            return this.slotChar.charAt(0);\n        },\n        seekNext(pos) {\n            while (++pos < this.len && !this.tests[pos]);\n\n            return pos;\n        },\n        seekPrev(pos) {\n            while (--pos >= 0 && !this.tests[pos]);\n\n            return pos;\n        },\n        shiftL(begin, end) {\n            let i, j;\n\n            if (begin < 0) {\n                return;\n            }\n\n            for (i = begin, j = this.seekNext(end); i < this.len; i++) {\n                if (this.tests[i]) {\n                    if (j < this.len && this.tests[i].test(this.buffer[j])) {\n                        this.buffer[i] = this.buffer[j];\n                        this.buffer[j] = this.getPlaceholder(j);\n                    } else {\n                        break;\n                    }\n\n                    j = this.seekNext(j);\n                }\n            }\n\n            this.writeBuffer();\n            this.caret(Math.max(this.firstNonMaskPos, begin));\n        },\n        shiftR(pos) {\n            let i, c, j, t;\n\n            for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {\n                if (this.tests[i]) {\n                    j = this.seekNext(i);\n                    t = this.buffer[i];\n                    this.buffer[i] = c;\n\n                    if (j < this.len && this.tests[j].test(t)) {\n                        c = t;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        },\n        handleAndroidInput(event) {\n            var curVal = this.$el.value;\n            var pos = this.caret();\n\n            if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {\n                // a deletion or backspace happened\n                this.checkVal(true);\n                while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;\n\n                if (pos.begin === 0) {\n                    while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;\n                }\n\n                this.caret(pos.begin, pos.begin);\n            } else {\n                this.checkVal(true);\n                while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;\n\n                this.caret(pos.begin, pos.begin);\n            }\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        clearBuffer(start, end) {\n            let i;\n\n            for (i = start; i < end && i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n                }\n            }\n        },\n        writeBuffer() {\n            this.$el.value = this.buffer.join('');\n        },\n        checkVal(allow) {\n            this.isValueChecked = true;\n            //try to place characters where they belong\n            let test = this.$el.value,\n                lastMatch = -1,\n                i,\n                c,\n                pos;\n\n            for (i = 0, pos = 0; i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n\n                    while (pos++ < test.length) {\n                        c = test.charAt(pos - 1);\n\n                        if (this.tests[i].test(c)) {\n                            this.buffer[i] = c;\n                            lastMatch = i;\n                            break;\n                        }\n                    }\n\n                    if (pos > test.length) {\n                        this.clearBuffer(i + 1, this.len);\n                        break;\n                    }\n                } else {\n                    if (this.buffer[i] === test.charAt(pos)) {\n                        pos++;\n                    }\n\n                    if (i < this.partialPosition) {\n                        lastMatch = i;\n                    }\n                }\n            }\n\n            if (allow) {\n                this.writeBuffer();\n            } else if (lastMatch + 1 < this.partialPosition) {\n                if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {\n                    // Invalid value. Remove it and replace it with the\n                    // mask, which is the default behavior.\n                    if (this.$el.value) this.$el.value = '';\n                    this.clearBuffer(0, this.len);\n                } else {\n                    // Invalid value, but we opt to show the value to the\n                    // user and allow them to correct their mistake.\n                    this.writeBuffer();\n                }\n            } else {\n                this.writeBuffer();\n                this.$el.value = this.$el.value.substring(0, lastMatch + 1);\n            }\n\n            return this.partialPosition ? i : this.firstNonMaskPos;\n        },\n        handleInputChange(event) {\n            const isPasteEvent = event.type === 'paste';\n\n            if (this.readonly || isPasteEvent) {\n                return;\n            }\n\n            var pos = this.checkVal(true);\n\n            this.caret(pos);\n            this.updateModel(event);\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        getUnmaskedValue() {\n            let unmaskedBuffer = [];\n\n            for (let i = 0; i < this.buffer.length; i++) {\n                let c = this.buffer[i];\n\n                if (this.tests[i] && c !== this.getPlaceholder(i)) {\n                    unmaskedBuffer.push(c);\n                }\n            }\n\n            return unmaskedBuffer.join('');\n        },\n        updateModel(e) {\n            let val = this.unmask ? this.getUnmaskedValue() : e.target.value;\n\n            this.$emit('update:modelValue', this.defaultBuffer !== val ? val : '');\n        },\n        updateValue(updateModel = true) {\n            if (this.$el) {\n                if (this.modelValue == null) {\n                    this.$el.value = '';\n                    updateModel && this.$emit('update:modelValue', '');\n                } else {\n                    this.$el.value = this.modelValue;\n                    this.checkVal();\n\n                    setTimeout(() => {\n                        if (this.$el) {\n                            this.writeBuffer();\n                            this.checkVal();\n\n                            if (updateModel) {\n                                let val = this.unmask ? this.getUnmaskedValue() : this.$el.value;\n\n                                this.$emit('update:modelValue', this.defaultBuffer !== val ? val : '');\n                            }\n                        }\n                    }, 10);\n                }\n\n                this.focusText = this.$el.value;\n            }\n        },\n        initMask() {\n            this.tests = [];\n            this.partialPosition = this.mask.length;\n            this.len = this.mask.length;\n            this.firstNonMaskPos = null;\n            this.defs = {\n                9: '[0-9]',\n                a: '[A-Za-z]',\n                '*': '[A-Za-z0-9]'\n            };\n\n            let ua = DomHandler.getUserAgent();\n\n            this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);\n\n            let maskTokens = this.mask.split('');\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c === '?') {\n                    this.len--;\n                    this.partialPosition = i;\n                } else if (this.defs[c]) {\n                    this.tests.push(new RegExp(this.defs[c]));\n\n                    if (this.firstNonMaskPos === null) {\n                        this.firstNonMaskPos = this.tests.length - 1;\n                    }\n\n                    if (i < this.partialPosition) {\n                        this.lastRequiredNonMaskPos = this.tests.length - 1;\n                    }\n                } else {\n                    this.tests.push(null);\n                }\n            }\n\n            this.buffer = [];\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c !== '?') {\n                    if (this.defs[c]) this.buffer.push(this.getPlaceholder(i));\n                    else this.buffer.push(c);\n                }\n            }\n\n            this.defaultBuffer = this.buffer.join('');\n            this.updateValue(false);\n        },\n        isValueUpdated() {\n            return this.unmask ? this.modelValue != this.getUnmaskedValue() : this.defaultBuffer !== this.$el.value && this.$el.value !== this.modelValue;\n        }\n    },\n    computed: {\n        filled() {\n            return this.modelValue != null && this.modelValue.toString().length > 0;\n        },\n        ptmParams() {\n            return {\n                context: {\n                    filled: this.filled\n                }\n            };\n        }\n    },\n    components: {\n        InputText\n    }\n};\n</script>\n"],
  "mappings": "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",
  "names": ["classes", "root", "BaseStyle", "extend", "name", "name", "BaseComponent", "props", "modelValue", "slotChar", "type", "String", "mask", "placeholder", "autoClear", "Boolean", "unmask", "readonly", "invalid", "disabled", "variant", "style", "InputMaskStyle", "provide", "$pcInputMask", "$parentInstance", "script", "BaseInputMask", "inheritAttrs", "emits", "watch", "newMask", "oldMask", "initMask", "mounted", "updated", "isValueUpdated", "updateValue", "methods", "onInput", "event", "androidChrome", "handleAndroidInput", "handleInputChange", "$emit", "target", "value", "onFocus", "_this", "focus", "clearTimeout", "caretTimeoutId", "pos", "focusText", "$el", "checkVal", "setTimeout", "document", "activeElement", "writeBuffer", "replace", "length", "caret", "onBlur", "updateModel", "e", "createEvent", "initEvent", "dispatchEvent", "onKeyDown", "k", "code", "begin", "end", "iPhone", "test", "DomHandler", "getUserAgent", "oldVal", "seekPrev", "seekNext", "clearBuffer", "shiftL", "preventDefault", "blur", "onKeyPress", "_this2", "p", "c", "next", "completed", "ctrlKey", "altKey", "metaKey", "shiftKey", "key", "len", "tests", "shiftR", "buffer", "proxy", "lastRequiredNonMaskPos", "isCompleted", "onPaste", "first", "last", "range", "offsetParent", "setSelectionRange", "collapse", "moveEnd", "moveStart", "select", "selectionStart", "selectionEnd", "createRange", "duplicate", "text", "i", "firstNonMaskPos", "getPlaceholder", "charAt", "j", "Math", "max", "t", "curVal", "start", "join", "allow", "isValueChecked", "lastMatch", "partialPosition", "defaultBuffer", "substring", "isPasteEvent", "getUnmaskedValue", "unmaskedBuffer", "push", "val", "_this3", "arguments", "undefined", "defs", "a", "ua", "maskTokens", "split", "RegExp", "computed", "filled", "toString", "ptmParams", "context", "components", "InputText", "_createBlock", "_component_InputText", "_ctx", "cx", "unstyled", "$options", "onKeydown", "onKeypress", "pt", "ptmi"]
}
